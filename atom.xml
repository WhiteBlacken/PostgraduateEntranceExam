<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://WhiteBlacken.github.io/</id>
    <title>Blog_qxy</title>
    <updated>2021-04-28T03:53:36.415Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://WhiteBlacken.github.io/"/>
    <link rel="self" href="https://WhiteBlacken.github.io/atom.xml"/>
    <subtitle>学习ing</subtitle>
    <logo>https://WhiteBlacken.github.io/images/avatar.png</logo>
    <icon>https://WhiteBlacken.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Blog_qxy</rights>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://WhiteBlacken.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://WhiteBlacken.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2021-04-26T10:08:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一章-概述">第一章 概述</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>定义</li>
<li>特征
<ul>
<li>并发
<ul>
<li>并发 vs 并行
<ul>
<li>举例
<ul>
<li>并发：海王交替在wx上和多个妹妹聊天（同一时间段）</li>
<li>并行：一边复习408一边听周杰伦（同一时刻）</li>
</ul>
</li>
<li>实现？
<ul>
<li>并发：单CPU可以引入进程</li>
<li>并行：多核CPU，不同CPU同时处理不同的任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享
<ul>
<li>系统中资源供多个并发执行的进程共同使用</li>
<li>共享方式
<ul>
<li>举例教室
<ul>
<li>教室前有一个时钟，大家都可以同时看，同时访问</li>
<li>教室里中饮水机同一时间只能一个人用，互斥访问</li>
<li>思考教室中的座位（教室中一个座位只能坐一位同学）</li>
</ul>
</li>
<li>互斥共享
<ul>
<li>临界资源/独占资源
<ul>
<li>一段时间内只允许一个进程访问的资源</li>
<li>多数物理设备（“正在占用摄像头”，打印机），栈，变量，表格</li>
<li>对临界资源的访问需要满足的原则
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
</ul>
</li>
<li>打印机如何体现互斥访问？如何改造成共享设备？
<ul>
<li>spooling技术</li>
</ul>
</li>
</ul>
</li>
<li>同时访问
<ul>
<li>可以是交替访问</li>
<li>磁盘设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟
<ul>
<li>虚拟处理器
<ul>
<li>多道程序并发执行</li>
</ul>
</li>
<li>虚拟内存
<ul>
<li>使用外存来扩充内存</li>
</ul>
</li>
<li>虚拟外部设备
<ul>
<li>独占设备改为共享设备</li>
</ul>
</li>
</ul>
</li>
<li>异步
<ul>
<li>进程并发执行，每个进程的进度和完成时间不可预测，即异步执行。</li>
<li>存在问题
<ul>
<li>对全局变量访问顺序不当会导致程序出错</li>
</ul>
</li>
<li>但是要保证运行环境相同，即使在异步执行的情况下，结果要相同。</li>
</ul>
</li>
</ul>
</li>
<li>提供的服务
<ul>
<li>计算机系统资源的管理者
<ul>
<li>处理机管理
<ul>
<li>谁来占用处理机</li>
<li>实际上是对进程的管理</li>
</ul>
</li>
<li>存储器管理
<ul>
<li>内存的分配与回收，地址映射，内存保护与共享，内存扩充</li>
</ul>
</li>
<li>设备管理</li>
<li>文件管理
<ul>
<li>信息的存储形式</li>
</ul>
</li>
</ul>
</li>
<li>提供用户和计算机硬件之间的接口</li>
<li>用作扩充机器
<ul>
<li>将裸机改造成实际使用的计算机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="发展与分类">发展与分类</h3>
<ul>
<li>手工操作（无操作系统）</li>
<li>批处理阶段
<ul>
<li>单道批处理</li>
<li>多道批处理</li>
</ul>
</li>
<li>分时操作系统</li>
<li>实时操作系统
<ul>
<li>硬实时</li>
<li>软实时</li>
</ul>
</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ul>
<h3 id="运行环境">运行环境</h3>
<ul>
<li>内核态 vs 用户态
<ul>
<li>举例：查账单</li>
<li>通过什么方式
<ul>
<li>系统调用</li>
<li>发生中断</li>
<li>发生错误状态</li>
<li>用户程序企图执行特权指令</li>
</ul>
</li>
</ul>
</li>
<li>中断 vs 异常
<ul>
<li>区别：中断源不同，举例：吃饭</li>
<li>中断的处理过程</li>
</ul>
</li>
<li>系统调用
<ul>
<li>用户程序调用资源的唯一方式</li>
</ul>
</li>
</ul>
<h3 id="体系结构">体系结构</h3>
<h2 id="第二章">第二章</h2>
<h3 id="进程与线程">进程与线程</h3>
<ul>
<li>为什么要进入进程
<ul>
<li>多道程序设计下，异步并发执行，为了更好描述和控制这种并发，引入了进程的概念</li>
</ul>
</li>
<li>进程的概念
<ul>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个基本单位</li>
<li>进程映象（进程实体）（静止）
<ul>
<li>程序段
<ul>
<li>可以被多个进程共享，即多个进程可以运行同一程序</li>
</ul>
</li>
<li>相关数据段
<ul>
<li>可以是原始数据，可以是中间数据，可以是最终数据</li>
</ul>
</li>
<li>PCB
<ul>
<li>常驻内存，进程存在的唯一标志</li>
<li>组织形式
<ul>
<li>链接方式</li>
<li>索引方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程vs程序</li>
<li>进程相关
<ul>
<li>进程的状态与转换
<ul>
<li>画图</li>
</ul>
</li>
<li>进程控制
<ul>
<li>使用原语
<ul>
<li>进程创建</li>
<li>进程终止</li>
<li>进程阻塞和唤醒</li>
<li>进程切换
<ul>
<li>进程切换vs处理机模式切换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程通信
<ul>
<li>共享存储</li>
<li>消息传递
<ul>
<li>发送消息和接收消息两个原语</li>
<li>方式
<ul>
<li>直接通信方式</li>
<li>间接通信方式
<ul>
<li>信箱通信方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>管道通信
<ul>
<li>管道：共享文件</li>
<li>管道和文件
<ul>
<li>管道的大小是由限制的，故可能会满</li>
<li>读进程可能比写进程快</li>
</ul>
</li>
<li>管道的特点
<ul>
<li>半双工：同一时刻只能单向传输，双向传输需要</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程 vs 线程</li>
</ul>
<h3 id="处理机调度">处理机调度</h3>
<ul>
<li>为什么要引入处理机调度</li>
<li>处理机调度的基本概念</li>
<li>时机</li>
<li>典型的调度算法</li>
</ul>
<h3 id="进程同步与互斥">进程同步与互斥</h3>
<h3 id="死锁">死锁</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android文件]]></title>
        <id>https://WhiteBlacken.github.io/post/android-wen-jian/</id>
        <link href="https://WhiteBlacken.github.io/post/android-wen-jian/">
        </link>
        <updated>2021-04-25T11:53:40.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>1</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android存储]]></title>
        <id>https://WhiteBlacken.github.io/post/android-cun-chu/</id>
        <link href="https://WhiteBlacken.github.io/post/android-cun-chu/">
        </link>
        <updated>2021-04-25T04:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="主流存储方式">主流存储方式</h2>
<ul>
<li>sp
<ul>
<li>配置信息（记住密码，上次浏览至）</li>
</ul>
</li>
<li>sqlite</li>
<li>room
<ul>
<li>相比较原生sqlite更简洁</li>
</ul>
</li>
</ul>
<h2 id="shared-preference">Shared Preference</h2>
<ul>
<li>使用场景
<ul>
<li>自动登录</li>
<li>记住密码</li>
<li>主题记录等</li>
</ul>
</li>
<li>特点
<ul>
<li>不能存在太多信息</li>
<li>运行时数据会全部加载进内容</li>
<li>键值对存储</li>
</ul>
</li>
</ul>
<h2 id="sqlite">Sqlite</h2>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>嵌入式设备：计算机、手表</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>嵌入式数据库，体积小，功能强大</li>
<li>数据类型
<ul>
<li>NULL</li>
<li>INTEGER</li>
<li>REAL（浮点数字）</li>
<li>TEXT（字符串文本）</li>
<li>BLOB（二进制）</li>
<li>也支持其他比如varchar(n),char(n),decimal(p,s)，但是最终会转成前五种数据类型</li>
</ul>
</li>
<li>主键必须为INTEGER，主键要求为_id（标准）或者id</li>
<li>底层sqlite.c动态创建数据库</li>
</ul>
<h3 id="使用的库">使用的库</h3>
<ul>
<li>SqliteOpenHelper</li>
</ul>
<h3 id="使用过程">使用过程</h3>
<ul>
<li>
<p>创建一个类实现SqliteOpenHelper接口</p>
<pre><code class="language-java">//工具类
//单例模式：1 构造函数初始化 2.对外提供函数
  public class MySqliteOpenHelper extends SQLiteOpenHelper {

      //单例模式
      private static SQLiteOpenHelper mInstance;
      public static synchronized SQLiteOpenHelper getInstance(Context context){
          if(mInstance == null){
              mInstance = new MySqliteOpenHelper(context,&quot;sqliteOne.db&quot;,null,1);
          }
          return mInstance;
      }
  //构造函数
      public MySqliteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {
          super(context, name, factory, version);
      }

      //数据库初始化 数据库第一次创建时访问 只会执行一次
      @Override
      public void onCreate(SQLiteDatabase sqLiteDatabase) {
          String sql = &quot;CREATE TABLE PERSON(_ID INTEGER PRIMARY KEY AUTOINCREMENT,NAME TEXT)&quot;;
          sqLiteDatabase.execSQL(sql);
      }
      //数据库升级
      @Override
      public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

      }
  }

</code></pre>
</li>
<li>
<p>创建数据库</p>
<pre><code class="language-java">public void createDB(View view) {
      SQLiteOpenHelper helper = MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase readableDB = helper.getReadableDatabase();
  }
</code></pre>
</li>
<li>
<p>查询数据库</p>
<pre><code class="language-java">public void queryDB(View view) {
      SQLiteOpenHelper helper = MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getReadableDatabase();

      if(db.isOpen()){
          //返回游标
          Cursor cursor = db.rawQuery(&quot;SELECT * FROM PERSON&quot;,null);
          while(cursor.moveToNext()) {
              int _id = cursor.getInt(cursor.getColumnIndex(&quot;_ID&quot;));
              String name = cursor.getString(cursor.getColumnIndex(&quot;NAME&quot;));

              Log.e(&quot;this&quot;,&quot;query _id:&quot;+_id+&quot;,name:&quot;+name);
          }
          //游标要关闭，否则耗费性能
          cursor.close();
          db.close();
      }
  }
</code></pre>
</li>
<li>
<p>插入数据</p>
<pre><code class="language-java">public void insertDB(View view) {
      SQLiteOpenHelper helper = MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getWritableDatabase();

      if(db.isOpen()){
          String sql = &quot;INSERT INTO PERSON(NAME) VALUES('QXY')&quot;;
          db.execSQL(sql);
          db.close();
      }
    
  }
</code></pre>
</li>
<li>
<p>更新数据库</p>
<pre><code class="language-java">public void updateDB(View view) {
      SQLiteOpenHelper helper =  MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getWritableDatabase();

      if(db.isOpen()){
          String sql = &quot;UPDATE PERSON SET NAME = ? WHERE _ID = ?&quot;;
          db.execSQL(sql,new Object[]{&quot;bxy&quot;,5});
          db.close();
      }
   
  }
</code></pre>
</li>
<li>
<p>删除记录</p>
<pre><code class="language-java">public void deleteDB(View view) {
      SQLiteOpenHelper helper =  MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getWritableDatabase();

      if(db.isOpen()){
          String sql = &quot;DELETE FROM PERSON WHERE _ID = ?&quot;;
          db.execSQL(sql,new Object[]{4});
          db.close();
      }
  }
</code></pre>
</li>
</ul>
<h2 id="room后续补充">Room（后续补充）</h2>
<h3 id="简介">简介</h3>
<ul>
<li>对Sqlite的封装</li>
<li>面向注解</li>
</ul>
<h3 id="三角色">三角色</h3>
<ul>
<li>Entity</li>
<li>Dao（用户只需操作dao）</li>
<li>Database
<h3 id="添加依赖">添加依赖</h3>
<pre><code class="language-gradle">  def room_version = &quot;2.2.0-alpha01&quot;
  implementation &quot;androidx.room:room-runtime:$room_version&quot;
  annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;
</code></pre>
</li>
</ul>
<h2 id="其他问题">其他问题</h2>
<ul>
<li>Context详解</li>
<li>package和folder有什么区别</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ul>
<li>https://www.bilibili.com/video/BV1Bi4y1A7oT?p=12&amp;spm_id_from=pageDriver</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android调用Camera]]></title>
        <id>https://WhiteBlacken.github.io/post/android-zi-ding-yi-diao-yong-camera/</id>
        <link href="https://WhiteBlacken.github.io/post/android-zi-ding-yi-diao-yong-camera/">
        </link>
        <updated>2021-04-23T07:47:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="两种方式">两种方式</h2>
<ul>
<li>调用系统的相机app（简单）</li>
<li>自定义使用Camera（灵活性高）</li>
</ul>
<h2 id="调用系统相机">调用系统相机</h2>
<ul>
<li>直接使用 <strong>new Intent(MediaStore.ACTION_IMAGE_CAPTURE)</strong></li>
<li>通过data获取的为缩略图，想要获得原图要通过文件路径读取文件。</li>
</ul>
<h2 id="自定义使用camera">自定义使用Camera</h2>
<h3 id="过程">过程</h3>
<ul>
<li>创建相机</li>
<li>创建SurfaceView</li>
<li>关联相机和SurfaceView</li>
<li>调整相机的显示效果</li>
<li>自定义相机预览界面</li>
</ul>
<h3 id="权限问题">权限问题</h3>
<ul>
<li>运行时权限需要自己手动在设置中打开</li>
<li>访问外部存储器时要在AndroidManifest.xml文件的application 标签下加上android:requestLegacyExternalStorage=&quot;true&quot;</li>
</ul>
<h3 id="选取摄像头">选取摄像头</h3>
<ul>
<li>通过Camera.open()  （以华为p30为例）
<ul>
<li>不带参数默认前置</li>
<li>参数0代表前置，参数1代表后置</li>
</ul>
</li>
<li>如何获取当前摄像头的信息？
<ul>
<li>数量：<strong>Camera.getNumberOfCameras()</strong>，能否检测到usb有待验证</li>
</ul>
</li>
</ul>
<h3 id="代码">代码</h3>
<h4 id="拍摄及预览">拍摄及预览</h4>
<pre><code class="language-java">public class PersonShot extends AppCompatActivity implements SurfaceHolder.Callback{
    private Camera mCamera;
    private SurfaceView mPreview;
    private SurfaceHolder mHolder;
    private Camera.PictureCallback mPictureCallBack = new Camera.PictureCallback() {
        @Override
        public void onPictureTaken(byte[] bytes, Camera camera) {
            //创建文件地址
            String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault()).format(new Date());//格式化时间戳
            String rootPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getPath();
            File tempFile = new File(rootPath + File.separator + timeStamp + &quot;.png&quot;);
            try {
                FileOutputStream fos = new FileOutputStream(tempFile);
                fos.write(bytes);
                fos.close();
                //此处跳转到ResultActivity来显示拍摄的照片
                Intent intent = new Intent(PersonShot.this, ResultActivity.class);
                intent.putExtra(&quot;picPath&quot;,tempFile.getAbsolutePath());
                startActivity(intent);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_person_shot);
//        checkNeedPermissions();
        mPreview = findViewById(R.id.preview);
        mHolder = mPreview.getHolder();
        mHolder.addCallback(this);
        //点击屏幕聚焦
        mPreview.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                mCamera.autoFocus(null);
            }
        });
    }
    //拍摄功能
    public void capture(View view) {
        Camera.Parameters parameters = mCamera.getParameters();
        parameters.setPictureFormat(ImageFormat.JPEG);
        parameters.setPreviewSize(800,400);
        //需要相机支持自动对焦
        parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
        mCamera.autoFocus(new Camera.AutoFocusCallback() {
            @Override
            public void onAutoFocus(boolean b, Camera camera) {
                if(b){
                    mCamera.takePicture(null,null,mPictureCallBack);
                }
            }
        });
    }


    @Override
    protected void onResume() {
        super.onResume();
        if(mCamera==null){
            mCamera = getCamera();
            if(mHolder!=null){
                setStartPreview(mCamera,mHolder);
            }
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        releaseCamera();
    }

    /**
     * 获取camera对象
     * @return
     */
    private Camera getCamera(){
        Camera camera;
        try {
            camera = Camera.open();
        }catch(Exception e){
            camera = null;
            e.printStackTrace();
        }
        return camera;
    }

    /**
     * 开始预览相机内容
     */
    private void setStartPreview(Camera camera,SurfaceHolder holder){
        try {
            camera.setPreviewDisplay(holder);
            //初始横屏，旋转90度
            camera.setDisplayOrientation(90);
            camera.startPreview();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    /**
     * 释放相机资源
     */
    private void releaseCamera(){
        if(mCamera!=null) {
            mCamera.setPreviewCallback(null);
            mCamera.stopPreview();
            mCamera.release();
            mCamera = null;
        }
    }

    //surfaceHolder的三个回调方法
    @Override
    public void surfaceCreated(SurfaceHolder surfaceHolder) {
        setStartPreview(mCamera,mHolder);
    }

    @Override
    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) {
        mCamera.stopPreview();
        setStartPreview(mCamera,mHolder);
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
        releaseCamera();
    }
</code></pre>
<h4 id="获取已拍摄图片">获取已拍摄图片</h4>
<pre><code class="language-java">public class ResultActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_result);
        String path = getIntent().getStringExtra(&quot;picPath&quot;);
        ImageView iv = findViewById(R.id.pic);
        //解决旋转问题
        Matrix matrix = new Matrix();
        matrix.setRotate(90);
        try {
            FileInputStream fis = new FileInputStream(path);
            Bitmap bitmap = BitmapFactory.decodeStream(fis);
            bitmap = Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true);
            iv.setImageBitmap(bitmap);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        //不需要旋转的简化版本
//        Bitmap bitmap = BitmapFactory.decodeFile(path);
//        iv.setImageBitmap(bitmap);
    }

}
</code></pre>
<h2 id="待解决">待解决</h2>
<ul>
<li>android读取相机拍摄文件崩溃？</li>
<li>bitmap,bundle?getExtras()?putExtra()</li>
<li>生命周期，如onResume，onPasue</li>
</ul>
]]></content>
    </entry>
</feed>