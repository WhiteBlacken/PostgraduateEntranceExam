<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://WhiteBlacken.github.io/</id>
    <title>Blog_qxy</title>
    <updated>2021-05-06T10:59:20.232Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://WhiteBlacken.github.io/"/>
    <link rel="self" href="https://WhiteBlacken.github.io/atom.xml"/>
    <subtitle>学习ing</subtitle>
    <logo>https://WhiteBlacken.github.io/images/avatar.png</logo>
    <icon>https://WhiteBlacken.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Blog_qxy</rights>
    <entry>
        <title type="html"><![CDATA[Git的使用]]></title>
        <id>https://WhiteBlacken.github.io/post/git-de-shi-yong/</id>
        <link href="https://WhiteBlacken.github.io/post/git-de-shi-yong/">
        </link>
        <updated>2021-05-06T04:31:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="本地使用">本地使用</h1>
<h2 id="初始化git仓库">初始化git仓库</h2>
<ul>
<li>git init</li>
</ul>
<h2 id="查看">查看</h2>
<ul>
<li>git status</li>
</ul>
<h2 id="操作暂存区">操作暂存区</h2>
<ul>
<li>git add xxx.xxx</li>
<li>git add -u
<ul>
<li>只添加被跟踪的文件</li>
</ul>
</li>
<li>git rm --cache xxx.xxx</li>
</ul>
<h2 id="提交只操作暂存区的文件">提交（只操作暂存区的文件）</h2>
<ul>
<li>git commit -m “first commit”</li>
<li>git commit（常用）</li>
</ul>
<h2 id="工作区向版本库对齐">工作区向版本库对齐</h2>
<ul>
<li>git reset --hard</li>
</ul>
<h1 id="远端仓库">远端仓库</h1>
<h2 id="设置">设置</h2>
<ul>
<li>git remote add origin 地址</li>
</ul>
<h2 id="查看-2">查看</h2>
<ul>
<li>git remote -v</li>
</ul>
<h2 id="本地提交到github">本地提交到github</h2>
<ul>
<li>git push origin -u origin main</li>
</ul>
<h1 id="浏览工作区状态与历史">浏览工作区状态与历史</h1>
<ul>
<li>git status -u
<ul>
<li>no -只显示已经跟踪的文件</li>
<li>normal -显示没有被跟踪的文件</li>
<li>all -未跟踪的文件夹内的文件<br>
<img src="https://WhiteBlacken.github.io//post-images/1620287048732.JPG" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h1 id="新建文件夹">新建文件夹</h1>
<ul>
<li>mkdir newfolder</li>
</ul>
<h1 id="操作文件">操作文件</h1>
<ul>
<li>基本信息
<ul>
<li>git config --global user.name “your name”</li>
<li>git config --global user.email “your email”</li>
<li>--global vs --local（当前工程）</li>
</ul>
</li>
<li>git add
<ul>
<li>filename</li>
<li>.</li>
<li>-u
<ul>
<li>修改（即已托管）</li>
</ul>
</li>
<li>-i
<ul>
<li>交互式（其他为批处理）</li>
</ul>
</li>
</ul>
</li>
<li>git commit
<ul>
<li>空</li>
<li>-a
<ul>
<li>add+commit（被跟踪的文件的才会执行）</li>
</ul>
</li>
<li>-m msg</li>
</ul>
</li>
</ul>
<h1 id="当前工作区搜索">当前工作区搜索</h1>
<ul>
<li>git grep -n content
<ul>
<li>工作区中查找</li>
</ul>
</li>
<li>git grep --untracked -n content</li>
</ul>
<h1 id="历史搜索中查找">历史搜索中查找</h1>
<ul>
<li>git log -G
<ul>
<li>从历史修改中查找</li>
</ul>
</li>
<li>git log -S
<ul>
<li>显示命中次数</li>
</ul>
</li>
</ul>
<h1 id="删除或移动文件">删除或移动文件</h1>
<ul>
<li>git rm</li>
<li>git mv</li>
</ul>
<h1 id="分支">分支</h1>
<ul>
<li>查看
<ul>
<li>git branch</li>
<li>git branch -avv</li>
</ul>
</li>
<li>新建分支
<ul>
<li>git branch branchname</li>
<li>git checkout branchname</li>
<li>git checkout -b branchname
<ul>
<li>新建+切换</li>
</ul>
</li>
</ul>
</li>
<li>推送分支
<ul>
<li>git push origin branch：branch</li>
<li>git push origin：branch
<ul>
<li>删除方法<br>
<img src="https://WhiteBlacken.github.io//post-images/1620290467737.JPG" alt="" loading="lazy"></li>
</ul>
</li>
<li>两种方法
<ul>
<li><img src="https://WhiteBlacken.github.io//post-images/1620289636575.JPG" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="修改">修改</h1>
<figure data-type="image" tabindex="2"><img src="https://WhiteBlacken.github.io//post-images/1620297782519.JPG" alt="" loading="lazy"></figure>
<ul>
<li>修改历史提交
<ul>
<li>git revert commitId</li>
</ul>
</li>
<li>修改上一个提交
<ul>
<li>git commit --amend</li>
<li>git commit --amend --author=”Author name“</li>
</ul>
</li>
<li>修改前几次提交
<ul>
<li>git rebase -i （交互式）</li>
</ul>
</li>
</ul>
<h1 id="使用">使用</h1>
<ul>
<li>寻找写错代码的人
<ul>
<li>git blame filename</li>
</ul>
</li>
<li>找回丢失的提交
<ul>
<li>git reflog</li>
<li>git checkout hashcode</li>
</ul>
</li>
<li>git瘦身
<ul>
<li>git gc</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次课程提纲]]></title>
        <id>https://WhiteBlacken.github.io/post/di-yi-ci-ke-cheng-ti-gang/</id>
        <link href="https://WhiteBlacken.github.io/post/di-yi-ci-ke-cheng-ti-gang/">
        </link>
        <updated>2021-05-04T06:08:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="从hello程序开始">从hello程序开始</h1>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
	printf(&quot;hello world\n&quot;);
	return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://WhiteBlacken.github.io//post-images/1620108824209.jpg" alt="" loading="lazy"></figure>
<ul>
<li>存储形式：ASCII码，字与字节</li>
<li>最终形式</li>
<li>程序若想运行，是否一定要调入内存？
<ul>
<li>进程的五态图
<ul>
<li>创建：PCB</li>
<li>就绪态：如何变成运行态？
<ul>
<li>处理机调度
<ul>
<li>为什么要进行处理机调度？</li>
<li>调度的层次</li>
<li>处理机调度的有哪些类型？</li>
<li>常见的调度算法？
<ul>
<li>先来先服务</li>
<li>短作业优先</li>
<li>优先级算法</li>
<li>高响应比</li>
<li>时间片轮转
<ul>
<li>抢占式？非抢占式？</li>
<li>这样做有什么好处？</li>
<li>时间片过长？时间片过短？</li>
<li>引入中断？
<ul>
<li>中断与异常？</li>
<li>为什么引入与中断？</li>
</ul>
</li>
</ul>
</li>
<li>多级反馈队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程并发执行带来的问题
<ul>
<li>需要调入内存，而内存有限
<ul>
<li>七态图</li>
</ul>
</li>
<li>死锁
<ul>
<li>产生的必要条件</li>
<li>处理方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>hello程序的运行<br>
<img src="https://WhiteBlacken.github.io//post-images/1620115984964.png" alt="" loading="lazy"><br>
<img src="https://WhiteBlacken.github.io//post-images/1620116664282.jpg" alt="" loading="lazy">
<ul>
<li>操作系统的四个特征
<ul>
<li>并发</li>
<li>虚拟
<ul>
<li>虚拟处理器</li>
<li>虚拟存储器
<ul>
<li>局部性原理</li>
</ul>
</li>
</ul>
</li>
<li>异步
<ul>
<li>为什么引入进程同步？
<ul>
<li>进程间制约关系
<ul>
<li>直接制约关系</li>
<li>间接制约关系
<ul>
<li>准则</li>
<li>实现临界区互斥的基本方法
<ul>
<li>软件
<ul>
<li>四种方法评价</li>
</ul>
</li>
<li>硬件
<ul>
<li>主要解决一气呵成问题</li>
<li>原语？</li>
</ul>
</li>
<li>信号量
<ul>
<li>p,v/wait,signal</li>
<li>类型
<ul>
<li>整型信号量</li>
<li>记录型信号量</li>
</ul>
</li>
<li>作用
<ul>
<li>实现同步</li>
<li>实现互斥</li>
</ul>
</li>
<li>经典同步问题<br>
<img src="https://WhiteBlacken.github.io//post-images/1620120033333.JPG" alt="" loading="lazy"><br>
<img src="https://WhiteBlacken.github.io//post-images/1620120039387.JPG" alt="" loading="lazy"><br>
<img src="https://WhiteBlacken.github.io//post-images/1620127605708.JPG" alt="" loading="lazy"><br>
改进？<br>
<img src="https://WhiteBlacken.github.io//post-images/1620128145688.JPG" alt="" loading="lazy"><br>
吸烟者问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享
<ul>
<li>类型
<ul>
<li>互斥共享</li>
<li>同时共享</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程通信
<ul>
<li>共享存储</li>
<li>消息传递</li>
<li>管道通信
<ul>
<li>管道vs文件
<ul>
<li>大小由限制</li>
<li>规则：空阻read，满组write</li>
</ul>
</li>
<li>半双工通信，全双工通信要定义两个管道</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编写操作系统之路]]></title>
        <id>https://WhiteBlacken.github.io/post/bian-xie-cao-zuo-xi-tong-zhi-lu/</id>
        <link href="https://WhiteBlacken.github.io/post/bian-xie-cao-zuo-xi-tong-zhi-lu/">
        </link>
        <updated>2021-04-28T03:59:22.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP]]></title>
        <id>https://WhiteBlacken.github.io/post/csapp/</id>
        <link href="https://WhiteBlacken.github.io/post/csapp/">
        </link>
        <updated>2021-04-28T03:54:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前置知识">前置知识</h1>
<ul>
<li>源程序到可执行程序
<ul>
<li><img src="https://WhiteBlacken.github.io//post-images/1619759005744.jpg" alt="" loading="lazy"></li>
<li>预处理器：读取系统头文件的内容，直接插入程序文本  .c -&gt;.i</li>
<li>编译器：将文本文件.i翻译为.s，这是一个汇编语言程序
<ul>
<li>汇编语言每条语句（出去mian，ret之类的）描述了一条低级机器语言指令</li>
<li>为不同高级语言提供通用的输出语句</li>
</ul>
</li>
<li>汇编：将汇编语言翻译为机器语言</li>
<li>链接：比如hello调用了printf函数（存在于标准c库中），printf函数存在于一个名为printf.o的单独的预编译好的目标文件，通过连接器将printf.o和hello.o合并，得到可执行文件</li>
</ul>
</li>
<li>冯诺依曼计算机
<ul>
<li><img src="https://WhiteBlacken.github.io//post-images/1619758194035.png" alt="" loading="lazy"></li>
<li>将计算机过程描述为许多条指令按照一定顺序组成的程序，并放入存储器保存</li>
<li>指令和数据均采用二进制进行存储</li>
<li>以运算器和控制器为中心</li>
<li>指令由操作码和地址码组成</li>
</ul>
</li>
<li>典型系统的硬件组成
<ul>
<li><img src="https://WhiteBlacken.github.io//post-images/1619759014339.jpg" alt="" loading="lazy"></li>
<li>总线
<ul>
<li>贯穿系统的一组电子管道</li>
<li>携带信息字节并负责在各个部件间传递</li>
<li>通常涉及成传送定长的字节块（即字）</li>
</ul>
</li>
<li>I/O设备
<ul>
<li>系统与外部世界联系的通道</li>
<li>一般包括
<ul>
<li>用户输入的键盘和鼠标</li>
<li>用户输出的显示屏</li>
<li>长期（对应“暂时”的内存）存储数据和程序磁盘驱动器</li>
</ul>
</li>
<li>每个I/O设备通过控制器或适配器与I/O总线相连
<ul>
<li>控制器与适配器封装方式不同，功能都是在I/O总线和I/O设备间传递信息
<ul>
<li>控制器：I/O设备本身或者系统主板上的芯片组</li>
<li>适配器：插在主板插槽上的一张卡</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>主存
<ul>
<li>临时存储设备
<ul>
<li>在处理器执行程序时，用来存放程序和程序处理的数据，有DRAM芯片组成
<ul>
<li>DRAM：断电数据消失</li>
</ul>
</li>
</ul>
</li>
<li>处理器
<ul>
<li>中央处理单元，解释（执行）存储在主存中指令的引擎</li>
<li>核心是PC：程序计数器，任何时刻都指向主存中某条指令的地址</li>
<li>从系统通电开始，处理器不断执行pc指向的指令，再更新pc，使其指向下一条</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>操作系统管理硬件
<ul>
<li>
<p>hello程序并无法直接访问键盘、显示屏、磁盘或者主存，需要依赖操作系统提供的服务</p>
</li>
<li>
<p>可以把操作系统看作是应用程序和硬件之间插入的一层软件</p>
</li>
<li>
<p>操作系统两个基本功能</p>
<ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>向硬件程序提供简单一致的机制来控制各不相同的低级硬件设备</li>
</ul>
</li>
<li>
<p>如何实现两个功能？</p>
<ul>
<li>通过基本的抽象概念</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>抽象</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程</td>
<td>处理器、I/O设备、主存</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>主存、磁盘I/O设备</td>
</tr>
<tr>
<td>文件</td>
<td>I/O设备</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>并发和并行的三个层次
<ul>
<li>线程级并发
<ul>
<li>模拟出来的，处理器在多个任务间雀环</li>
</ul>
</li>
<li>指令级并行
<ul>
<li>流水性的应用</li>
</ul>
</li>
<li>单指令、多数据并行
<ul>
<li>并行的对8对单精度浮点数做加法指令</li>
</ul>
</li>
</ul>
</li>
<li>抽象</li>
<li>CPU利用率，CPU与设备的速度差异，如何安排两个任务：计算密集型，I/O密集型</li>
</ul>
<h1 id="从进程开始">从进程开始</h1>
<ul>
<li>进程是什么？
<ul>
<li>进程操作系统对一个正在运行的程序的一种抽象，一个系统可以同时运行多个进程，每个进程都好像在独占地使用设备。</li>
</ul>
</li>
<li>上下文切换
<ul>
<li>并发执行通过处理器在进程间的切换来实现，实现交替执行的机制称作上下文切换</li>
<li>上下文：操作系统保持跟踪进程运行所需的所有状态信息
<ul>
<li>PC</li>
<li>寄存器文件的当前值</li>
<li>主存中的内容</li>
</ul>
</li>
<li>对于单核CPU来说，任意时刻只能执行一个进程的代码，所以操作系统要决定控制权的归属
<ul>
<li>过程
<ul>
<li>保存当前进程的上下文</li>
<li>恢复新进程的上下文</li>
<li>将控制权传递给新进程</li>
</ul>
</li>
</ul>
</li>
<li>进程切换在操作系统内核管理的</li>
</ul>
</li>
<li>引入线程
<ul>
<li>一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，共享代码和全局数据</li>
<li>多线程之间相对多进程之间更容易共享数据，线程一般来说比进程更高效</li>
</ul>
</li>
<li>进程提供给应用程序的两个抽象
<ul>
<li>独立的逻辑控制流
<ul>
<li>假象：程序独占的使用处理器</li>
</ul>
</li>
<li>私有的地址空间
<ul>
<li>假象：程序独占的使用内存系统
<ul>
<li>进程为每个程序提供它自己的私有地址空间，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://WhiteBlacken.github.io//post-images/1619764590492.jpg" alt="" loading="lazy">
<ul>
<li>上下文切换</li>
<li>系统调用</li>
</ul>
</li>
<li>进程通信
<ul>
<li>因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显示的进程间通信（interprocess communication）机制，安全但是开销很高</li>
</ul>
</li>
<li>死锁</li>
</ul>
<h1 id="存储管理">存储管理</h1>
<ul>
<li>从程序执行的数据流看高速缓存（结合典型硬件组成）
<ul>
<li>hello程序从输入到执行，经过了多次复制传输，造成了大量的时间开销，减少这种开销是必要的。</li>
<li>局部性原理+机械原理-&gt;通过高速缓存可以提高系统性能</li>
</ul>
</li>
<li>存储设备的层次结构</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://WhiteBlacken.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://WhiteBlacken.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2021-04-26T10:08:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一章-概述">第一章 概述</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>定义</li>
<li>特征
<ul>
<li>并发
<ul>
<li>并发 vs 并行
<ul>
<li>举例
<ul>
<li>并发：海王交替在wx上和多个妹妹聊天（同一时间段）</li>
<li>并行：一边复习408一边听周杰伦（同一时刻）</li>
</ul>
</li>
<li>实现？
<ul>
<li>并发：单CPU可以引入进程</li>
<li>并行：多核CPU，不同CPU同时处理不同的任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享
<ul>
<li>系统中资源供多个并发执行的进程共同使用</li>
<li>共享方式
<ul>
<li>举例教室
<ul>
<li>教室前有一个时钟，大家都可以同时看，同时访问</li>
<li>教室里中饮水机同一时间只能一个人用，互斥访问</li>
<li>思考教室中的座位（教室中一个座位只能坐一位同学）</li>
</ul>
</li>
<li>互斥共享
<ul>
<li>临界资源/独占资源
<ul>
<li>一段时间内只允许一个进程访问的资源</li>
<li>多数物理设备（“正在占用摄像头”，打印机），栈，变量，表格</li>
<li>对临界资源的访问需要满足的原则
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
</ul>
</li>
<li>打印机如何体现互斥访问？如何改造成共享设备？
<ul>
<li>spooling技术</li>
</ul>
</li>
</ul>
</li>
<li>同时访问
<ul>
<li>可以是交替访问</li>
<li>磁盘设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟
<ul>
<li>虚拟处理器
<ul>
<li>多道程序并发执行</li>
</ul>
</li>
<li>虚拟内存
<ul>
<li>使用外存来扩充内存</li>
</ul>
</li>
<li>虚拟外部设备
<ul>
<li>独占设备改为共享设备</li>
</ul>
</li>
</ul>
</li>
<li>异步
<ul>
<li>进程并发执行，每个进程的进度和完成时间不可预测，即异步执行。</li>
<li>存在问题
<ul>
<li>对全局变量访问顺序不当会导致程序出错</li>
</ul>
</li>
<li>但是要保证运行环境相同，即使在异步执行的情况下，结果要相同。</li>
</ul>
</li>
</ul>
</li>
<li>提供的服务
<ul>
<li>计算机系统资源的管理者
<ul>
<li>处理机管理
<ul>
<li>谁来占用处理机</li>
<li>实际上是对进程的管理</li>
</ul>
</li>
<li>存储器管理
<ul>
<li>内存的分配与回收，地址映射，内存保护与共享，内存扩充</li>
</ul>
</li>
<li>设备管理</li>
<li>文件管理
<ul>
<li>信息的存储形式</li>
</ul>
</li>
</ul>
</li>
<li>提供用户和计算机硬件之间的接口</li>
<li>用作扩充机器
<ul>
<li>将裸机改造成实际使用的计算机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="发展与分类">发展与分类</h3>
<ul>
<li>手工操作（无操作系统）</li>
<li>批处理阶段
<ul>
<li>单道批处理</li>
<li>多道批处理</li>
</ul>
</li>
<li>分时操作系统</li>
<li>实时操作系统
<ul>
<li>硬实时</li>
<li>软实时</li>
</ul>
</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ul>
<h3 id="运行环境">运行环境</h3>
<ul>
<li>内核态 vs 用户态
<ul>
<li>举例：查账单</li>
<li>通过什么方式
<ul>
<li>系统调用</li>
<li>发生中断</li>
<li>发生错误状态</li>
<li>用户程序企图执行特权指令</li>
</ul>
</li>
</ul>
</li>
<li>中断 vs 异常
<ul>
<li>区别：中断源不同，举例：吃饭</li>
<li>中断的处理过程</li>
</ul>
</li>
<li>系统调用
<ul>
<li>用户程序调用资源的唯一方式</li>
</ul>
</li>
</ul>
<h3 id="体系结构">体系结构</h3>
<h2 id="第二章">第二章</h2>
<h3 id="进程与线程">进程与线程</h3>
<ul>
<li>为什么要进入进程
<ul>
<li>多道程序设计下，异步并发执行，为了更好描述和控制这种并发，引入了进程的概念</li>
</ul>
</li>
<li>进程的概念
<ul>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个基本单位</li>
<li>进程映象（进程实体）（静止）
<ul>
<li>程序段
<ul>
<li>可以被多个进程共享，即多个进程可以运行同一程序</li>
</ul>
</li>
<li>相关数据段
<ul>
<li>可以是原始数据，可以是中间数据，可以是最终数据</li>
</ul>
</li>
<li>PCB
<ul>
<li>常驻内存，进程存在的唯一标志</li>
<li>组织形式
<ul>
<li>链接方式</li>
<li>索引方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程vs程序</li>
<li>进程相关
<ul>
<li>进程的状态与转换
<ul>
<li>画图</li>
</ul>
</li>
<li>进程控制
<ul>
<li>使用原语
<ul>
<li>进程创建</li>
<li>进程终止</li>
<li>进程阻塞和唤醒</li>
<li>进程切换
<ul>
<li>进程切换vs处理机模式切换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程通信
<ul>
<li>共享存储</li>
<li>消息传递
<ul>
<li>发送消息和接收消息两个原语</li>
<li>方式
<ul>
<li>直接通信方式</li>
<li>间接通信方式
<ul>
<li>信箱通信方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>管道通信
<ul>
<li>管道：共享文件</li>
<li>管道和文件
<ul>
<li>管道的大小是由限制的，故可能会满</li>
<li>读进程可能比写进程快</li>
</ul>
</li>
<li>管道的特点
<ul>
<li>半双工：同一时刻只能单向传输，双向传输需要</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程 vs 线程</li>
</ul>
<h3 id="处理机调度">处理机调度</h3>
<ul>
<li>为什么要引入处理机调度</li>
<li>处理机调度的基本概念</li>
<li>时机</li>
<li>典型的调度算法</li>
</ul>
<h3 id="进程同步与互斥">进程同步与互斥</h3>
<h3 id="死锁">死锁</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android文件]]></title>
        <id>https://WhiteBlacken.github.io/post/android-wen-jian/</id>
        <link href="https://WhiteBlacken.github.io/post/android-wen-jian/">
        </link>
        <updated>2021-04-25T11:53:40.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>1</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android存储]]></title>
        <id>https://WhiteBlacken.github.io/post/android-cun-chu/</id>
        <link href="https://WhiteBlacken.github.io/post/android-cun-chu/">
        </link>
        <updated>2021-04-25T04:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="主流存储方式">主流存储方式</h2>
<ul>
<li>sp
<ul>
<li>配置信息（记住密码，上次浏览至）</li>
</ul>
</li>
<li>sqlite</li>
<li>room
<ul>
<li>相比较原生sqlite更简洁</li>
</ul>
</li>
</ul>
<h2 id="shared-preference">Shared Preference</h2>
<ul>
<li>使用场景
<ul>
<li>自动登录</li>
<li>记住密码</li>
<li>主题记录等</li>
</ul>
</li>
<li>特点
<ul>
<li>不能存在太多信息</li>
<li>运行时数据会全部加载进内容</li>
<li>键值对存储</li>
</ul>
</li>
</ul>
<h2 id="sqlite">Sqlite</h2>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>嵌入式设备：计算机、手表</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>嵌入式数据库，体积小，功能强大</li>
<li>数据类型
<ul>
<li>NULL</li>
<li>INTEGER</li>
<li>REAL（浮点数字）</li>
<li>TEXT（字符串文本）</li>
<li>BLOB（二进制）</li>
<li>也支持其他比如varchar(n),char(n),decimal(p,s)，但是最终会转成前五种数据类型</li>
</ul>
</li>
<li>主键必须为INTEGER，主键要求为_id（标准）或者id</li>
<li>底层sqlite.c动态创建数据库</li>
</ul>
<h3 id="使用的库">使用的库</h3>
<ul>
<li>SqliteOpenHelper</li>
</ul>
<h3 id="使用过程">使用过程</h3>
<ul>
<li>
<p>创建一个类实现SqliteOpenHelper接口</p>
<pre><code class="language-java">//工具类
//单例模式：1 构造函数初始化 2.对外提供函数
  public class MySqliteOpenHelper extends SQLiteOpenHelper {

      //单例模式
      private static SQLiteOpenHelper mInstance;
      public static synchronized SQLiteOpenHelper getInstance(Context context){
          if(mInstance == null){
              mInstance = new MySqliteOpenHelper(context,&quot;sqliteOne.db&quot;,null,1);
          }
          return mInstance;
      }
  //构造函数
      public MySqliteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {
          super(context, name, factory, version);
      }

      //数据库初始化 数据库第一次创建时访问 只会执行一次
      @Override
      public void onCreate(SQLiteDatabase sqLiteDatabase) {
          String sql = &quot;CREATE TABLE PERSON(_ID INTEGER PRIMARY KEY AUTOINCREMENT,NAME TEXT)&quot;;
          sqLiteDatabase.execSQL(sql);
      }
      //数据库升级
      @Override
      public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

      }
  }

</code></pre>
</li>
<li>
<p>创建数据库</p>
<pre><code class="language-java">public void createDB(View view) {
      SQLiteOpenHelper helper = MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase readableDB = helper.getReadableDatabase();
  }
</code></pre>
</li>
<li>
<p>查询数据库</p>
<pre><code class="language-java">public void queryDB(View view) {
      SQLiteOpenHelper helper = MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getReadableDatabase();

      if(db.isOpen()){
          //返回游标
          Cursor cursor = db.rawQuery(&quot;SELECT * FROM PERSON&quot;,null);
          while(cursor.moveToNext()) {
              int _id = cursor.getInt(cursor.getColumnIndex(&quot;_ID&quot;));
              String name = cursor.getString(cursor.getColumnIndex(&quot;NAME&quot;));

              Log.e(&quot;this&quot;,&quot;query _id:&quot;+_id+&quot;,name:&quot;+name);
          }
          //游标要关闭，否则耗费性能
          cursor.close();
          db.close();
      }
  }
</code></pre>
</li>
<li>
<p>插入数据</p>
<pre><code class="language-java">public void insertDB(View view) {
      SQLiteOpenHelper helper = MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getWritableDatabase();

      if(db.isOpen()){
          String sql = &quot;INSERT INTO PERSON(NAME) VALUES('QXY')&quot;;
          db.execSQL(sql);
          db.close();
      }
    
  }
</code></pre>
</li>
<li>
<p>更新数据库</p>
<pre><code class="language-java">public void updateDB(View view) {
      SQLiteOpenHelper helper =  MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getWritableDatabase();

      if(db.isOpen()){
          String sql = &quot;UPDATE PERSON SET NAME = ? WHERE _ID = ?&quot;;
          db.execSQL(sql,new Object[]{&quot;bxy&quot;,5});
          db.close();
      }
   
  }
</code></pre>
</li>
<li>
<p>删除记录</p>
<pre><code class="language-java">public void deleteDB(View view) {
      SQLiteOpenHelper helper =  MySqliteOpenHelper.getInstance(this);
      SQLiteDatabase db = helper.getWritableDatabase();

      if(db.isOpen()){
          String sql = &quot;DELETE FROM PERSON WHERE _ID = ?&quot;;
          db.execSQL(sql,new Object[]{4});
          db.close();
      }
  }
</code></pre>
</li>
</ul>
<h2 id="room后续补充">Room（后续补充）</h2>
<h3 id="简介">简介</h3>
<ul>
<li>对Sqlite的封装</li>
<li>面向注解</li>
</ul>
<h3 id="三角色">三角色</h3>
<ul>
<li>Entity</li>
<li>Dao（用户只需操作dao）</li>
<li>Database
<h3 id="添加依赖">添加依赖</h3>
<pre><code class="language-gradle">  def room_version = &quot;2.2.0-alpha01&quot;
  implementation &quot;androidx.room:room-runtime:$room_version&quot;
  annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;
</code></pre>
</li>
</ul>
<h2 id="其他问题">其他问题</h2>
<ul>
<li>Context详解</li>
<li>package和folder有什么区别</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ul>
<li>https://www.bilibili.com/video/BV1Bi4y1A7oT?p=12&amp;spm_id_from=pageDriver</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android调用Camera]]></title>
        <id>https://WhiteBlacken.github.io/post/android-zi-ding-yi-diao-yong-camera/</id>
        <link href="https://WhiteBlacken.github.io/post/android-zi-ding-yi-diao-yong-camera/">
        </link>
        <updated>2021-04-23T07:47:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="两种方式">两种方式</h2>
<ul>
<li>调用系统的相机app（简单）</li>
<li>自定义使用Camera（灵活性高）</li>
</ul>
<h2 id="调用系统相机">调用系统相机</h2>
<ul>
<li>直接使用 <strong>new Intent(MediaStore.ACTION_IMAGE_CAPTURE)</strong></li>
<li>通过data获取的为缩略图，想要获得原图要通过文件路径读取文件。</li>
</ul>
<h2 id="自定义使用camera">自定义使用Camera</h2>
<h3 id="过程">过程</h3>
<ul>
<li>创建相机</li>
<li>创建SurfaceView</li>
<li>关联相机和SurfaceView</li>
<li>调整相机的显示效果</li>
<li>自定义相机预览界面</li>
</ul>
<h3 id="权限问题">权限问题</h3>
<ul>
<li>运行时权限需要自己手动在设置中打开</li>
<li>访问外部存储器时要在AndroidManifest.xml文件的application 标签下加上android:requestLegacyExternalStorage=&quot;true&quot;</li>
</ul>
<h3 id="选取摄像头">选取摄像头</h3>
<ul>
<li>通过Camera.open()  （以华为p30为例）
<ul>
<li>不带参数默认前置</li>
<li>参数0代表前置，参数1代表后置</li>
</ul>
</li>
<li>如何获取当前摄像头的信息？
<ul>
<li>数量：<strong>Camera.getNumberOfCameras()</strong>，能否检测到usb有待验证</li>
</ul>
</li>
</ul>
<h3 id="代码">代码</h3>
<h4 id="拍摄及预览">拍摄及预览</h4>
<pre><code class="language-java">public class PersonShot extends AppCompatActivity implements SurfaceHolder.Callback{
    private Camera mCamera;
    private SurfaceView mPreview;
    private SurfaceHolder mHolder;
    private Camera.PictureCallback mPictureCallBack = new Camera.PictureCallback() {
        @Override
        public void onPictureTaken(byte[] bytes, Camera camera) {
            //创建文件地址
            String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault()).format(new Date());//格式化时间戳
            String rootPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getPath();
            File tempFile = new File(rootPath + File.separator + timeStamp + &quot;.png&quot;);
            try {
                FileOutputStream fos = new FileOutputStream(tempFile);
                fos.write(bytes);
                fos.close();
                //此处跳转到ResultActivity来显示拍摄的照片
                Intent intent = new Intent(PersonShot.this, ResultActivity.class);
                intent.putExtra(&quot;picPath&quot;,tempFile.getAbsolutePath());
                startActivity(intent);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_person_shot);
//        checkNeedPermissions();
        mPreview = findViewById(R.id.preview);
        mHolder = mPreview.getHolder();
        mHolder.addCallback(this);
        //点击屏幕聚焦
        mPreview.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                mCamera.autoFocus(null);
            }
        });
    }
    //拍摄功能
    public void capture(View view) {
        Camera.Parameters parameters = mCamera.getParameters();
        parameters.setPictureFormat(ImageFormat.JPEG);
        parameters.setPreviewSize(800,400);
        //需要相机支持自动对焦
        parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
        mCamera.autoFocus(new Camera.AutoFocusCallback() {
            @Override
            public void onAutoFocus(boolean b, Camera camera) {
                if(b){
                    mCamera.takePicture(null,null,mPictureCallBack);
                }
            }
        });
    }


    @Override
    protected void onResume() {
        super.onResume();
        if(mCamera==null){
            mCamera = getCamera();
            if(mHolder!=null){
                setStartPreview(mCamera,mHolder);
            }
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        releaseCamera();
    }

    /**
     * 获取camera对象
     * @return
     */
    private Camera getCamera(){
        Camera camera;
        try {
            camera = Camera.open();
        }catch(Exception e){
            camera = null;
            e.printStackTrace();
        }
        return camera;
    }

    /**
     * 开始预览相机内容
     */
    private void setStartPreview(Camera camera,SurfaceHolder holder){
        try {
            camera.setPreviewDisplay(holder);
            //初始横屏，旋转90度
            camera.setDisplayOrientation(90);
            camera.startPreview();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    /**
     * 释放相机资源
     */
    private void releaseCamera(){
        if(mCamera!=null) {
            mCamera.setPreviewCallback(null);
            mCamera.stopPreview();
            mCamera.release();
            mCamera = null;
        }
    }

    //surfaceHolder的三个回调方法
    @Override
    public void surfaceCreated(SurfaceHolder surfaceHolder) {
        setStartPreview(mCamera,mHolder);
    }

    @Override
    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) {
        mCamera.stopPreview();
        setStartPreview(mCamera,mHolder);
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
        releaseCamera();
    }
</code></pre>
<h4 id="获取已拍摄图片">获取已拍摄图片</h4>
<pre><code class="language-java">public class ResultActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_result);
        String path = getIntent().getStringExtra(&quot;picPath&quot;);
        ImageView iv = findViewById(R.id.pic);
        //解决旋转问题
        Matrix matrix = new Matrix();
        matrix.setRotate(90);
        try {
            FileInputStream fis = new FileInputStream(path);
            Bitmap bitmap = BitmapFactory.decodeStream(fis);
            bitmap = Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true);
            iv.setImageBitmap(bitmap);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        //不需要旋转的简化版本
//        Bitmap bitmap = BitmapFactory.decodeFile(path);
//        iv.setImageBitmap(bitmap);
    }

}
</code></pre>
<h2 id="待解决">待解决</h2>
<ul>
<li>android读取相机拍摄文件崩溃？</li>
<li>bitmap,bundle?getExtras()?putExtra()</li>
<li>生命周期，如onResume，onPasue</li>
</ul>
]]></content>
    </entry>
</feed>